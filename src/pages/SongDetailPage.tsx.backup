import { useEffect, useState, useRef } from "react";
import {
  Box,
  SimpleGrid,
  GridItem,
  Heading,
  Img,
  Spinner,
  Text,
  HStack,
} from "@chakra-ui/react";
import { Link, Navigate, useParams } from "react-router-dom";
import ExpandableText from "../components/ExpandableText";
import useMedia from "../hooks/useMediaFile";
import { MEDIA_BASE_URL } from "../data/constants";
import DefinitionItem from "../components/DefinitionItem";
import SongAttributes from "../components/SongAttributes";
import Views from "../components/Views";
import useLike from "../hooks/useLike";
import Like from "../components/Like";
import useUnlike from "../hooks/useUnlike";
import useLikeStatus from "../hooks/useLikeStatus";
import YouTube from "react-youtube";

const SongDetailPage = () => {
  const jwt = localStorage.getItem("token");
  if (!jwt) return <Navigate to="/auth" />;

  const { id } = useParams();
  if (!id) return <Text color="red.500">Invalid ID.</Text>;

  const {
    media: mediaFile,
    loading: mediaLoading,
    error: mediaError,
  } = useMedia(id!);

  const [errorMessage, setErrorMessage] = useState("");

  // Get the song ID from the media file
  const songId = mediaFile?.song?._id;

  // Use the new like status hook
  const {
    likeStatus,
    loading: likeStatusLoading,
    refetch: refetchLikeStatus,
  } = useLikeStatus(songId || "");

  // Initialize like hooks with song ID
  const { likeSong } = useLike(songId || "");
  const { unlikeSong } = useUnlike(songId || "");

  // Optimistic state for immediate UI updates
  const [optimisticLikeState, setOptimisticLikeState] = useState<{
    isLiked: boolean;
    likesCount: number;
  } | null>(null);

  // Loading state for like/unlike operations
  const [isLikeOperationLoading, setIsLikeOperationLoading] = useState(false);

  // Ref to track if we're in the middle of a like operation
  const isInLikeOperation = useRef(false);

  // Ref to store timeout ID for cleanup
  const syncTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Update optimistic state when likeStatus changes (but only if there's a significant difference)
  useEffect(() => {
    if (likeStatus && optimisticLikeState && !isInLikeOperation.current) {
      // Only update if the server state is different from our optimistic state
      // This prevents immediate reversion after successful operations
      const serverIsLiked = likeStatus.isLiked;
      const optimisticIsLiked = optimisticLikeState.isLiked;

      // If the states are different, it means we need to sync
      if (
        serverIsLiked !== optimisticIsLiked ||
        likeStatus.likesCount !== optimisticLikeState.likesCount
      ) {
        setOptimisticLikeState({
          isLiked: likeStatus.isLiked,
          likesCount: likeStatus.likesCount,
        });
      }
    } else if (likeStatus && !optimisticLikeState) {
      // Initial load - set the optimistic state
      setOptimisticLikeState({
        isLiked: likeStatus.isLiked,
        likesCount: likeStatus.likesCount,
      });
    }
  }, [likeStatus]);

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (syncTimeoutRef.current) {
        clearTimeout(syncTimeoutRef.current);
      }
    };
  }, []);

  const handleLike = async () => {
    if (!songId || !optimisticLikeState) return;

    // Store the current state for potential rollback
    const previousState = { ...optimisticLikeState };

    try {
      setIsLikeOperationLoading(true);
      isInLikeOperation.current = true;

      // Optimistically update the UI immediately
      setOptimisticLikeState((prev) => ({
        isLiked: !prev!.isLiked,
        likesCount: prev!.likesCount + (!prev!.isLiked ? 1 : -1),
      }));

      // Perform the API call
      if (!optimisticLikeState.isLiked) {
        await likeSong();
      } else {
        await unlikeSong();
      }

      // Don't refetch immediately - let the optimistic state persist
      // Sync with server state after a delay to ensure consistency
      syncTimeoutRef.current = setTimeout(() => {
        if (!isInLikeOperation.current) {
          refetchLikeStatus();
        }
      }, 2000); // 2 second delay

      setErrorMessage(""); // Clear any existing error message
    } catch (error: any) {
      console.error("Error toggling like status:", error);
      // Revert the optimistic update on error
      setOptimisticLikeState(previousState);
      setErrorMessage(
        error.message || "Failed to update like status. Please try again."
      );
    } finally {
      setIsLikeOperationLoading(false);
      isInLikeOperation.current = false;
    }
  };

  // Update the return type to string | undefined
  const getYoutubeVideoId = (url?: string): string | undefined => {
    if (!url) return undefined;
    const regExp =
      /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
    const match = url.match(regExp);
    return match && match[2].length === 11 ? match[2] : undefined; // Return undefined instead of null
  };

  if (mediaLoading) return <Spinner />;

  // Show error messages if applicable
  if (mediaError) return <Text color="red.500">{mediaError}</Text>;

  // Ensure documentFile and song are available before rendering
  if (!mediaFile) return <Text>No document found.</Text>;

  // Fallback: If no song, show media file info
  if (!mediaFile.song) {
    return (
      <SimpleGrid columns={{ base: 1, md: 2 }} spacing={5}>
        <GridItem>
          <Heading>{mediaFile.name}</Heading>
          <Link to={mediaFile.documentFile}>
            <Img
              src={mediaFile.previewImage}
              boxSize="700px"
              objectFit="cover"
              alt={`Preview image for ${mediaFile.name}`}
            />
          </Link>
          <br />
          {mediaFile.audioFile ? (
            <>
              <audio controls src={mediaFile.audioFile}>
                Your browser does not support the audio element.
              </audio>
              <br />
            </>
          ) : (
            <Text>No audio available for this song.</Text>
          )}
          <Heading>Notation</Heading>
          <Text>{mediaFile.notation?.title || "N/A"}</Text>
        </GridItem>
        <GridItem>
          <Heading mt={6}>Document</Heading>
          <Text>
            <a
              href={mediaFile.documentFile}
              target="_blank"
              rel="noopener noreferrer"
            >
              View Document
            </a>
          </Text>
        </GridItem>
      </SimpleGrid>
    );
  }

  const { song, documentFile, previewImage, audioFile } = mediaFile;

  return (
    <SimpleGrid columns={{ base: 1, md: 2 }} spacing={5}>
      {/* First Column */}
      <GridItem>
        <Heading>{song.title}</Heading>
        <Link to={documentFile}>
          <Img
            src={previewImage}
            boxSize="700px"
            objectFit="cover"
            alt={`Preview image for ${song?.title || "song"}`}
          />
        </Link>
        <br />
        {audioFile ? (
          <>
            <audio controls src={audioFile}>
              Your browser does not support the audio element.
            </audio>
            <br />
          </>
        ) : (
          <Text>No audio available for this song.</Text>
        )}

        <Heading>Background</Heading>

        <ExpandableText>
          {song!.description || "No description available."}
        </ExpandableText>
      </GridItem>

      {/* Second Column */}
      <GridItem>
        {song.youtubeUrl && (
          <>
            <Box my={4} width="100%" display="flex" justifyContent="center">
              <Box width={{ base: "80%", md: "500px" }}>
                <YouTube
                  videoId={getYoutubeVideoId(song.youtubeUrl)}
                  opts={{
                    width: "100%",
                    height: "300",
                    playerVars: {
                      autoplay: 0,
                    },
                  }}
                />
              </Box>
            </Box>
            <br />
          </>
        )}
        <Heading mt={6}>Lyrics</Heading>
        <Text>{song!.lyrics || "No lyrics available."}</Text>
        <SongAttributes mediaFile={mediaFile!} />

        <SimpleGrid columns={2} as="dl" spacing={4}>
          <DefinitionItem term="Likes">
            <Box>
              <HStack>
                {likeStatusLoading ? (
                  <Spinner size="sm" />
                ) : (
                  <Like
                    liked={optimisticLikeState?.isLiked || false}
                    onLike={isLikeOperationLoading ? undefined : handleLike}
                  />
                )}
                <Text
                  padding={2}
                  transition="all 0.2s ease-in-out"
                  color={optimisticLikeState?.isLiked ? "red.500" : "inherit"}
                >
                  {optimisticLikeState?.likesCount || 0}
                </Text>
                {errorMessage && <Text color="red.500">{errorMessage}</Text>}
              </HStack>
            </Box>
          </DefinitionItem>
          <DefinitionItem term="Views">
            <Box>
              <HStack>
                <Views />
                <Text padding={2}>{song!.views}</Text>
              </HStack>
            </Box>
          </DefinitionItem>
        </SimpleGrid>
      </GridItem>
    </SimpleGrid>
  );
};

export default SongDetailPage;
